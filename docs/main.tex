\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{dirtytalk}
\usepackage{caratula}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{geometry}
\usepackage{fixltx2e}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{ dsfont }
\usepackage{float}
\usepackage[space]{grffile}
\usepackage{tpalgo3}
\geometry{
 a4paper,
 total={210mm,297mm},
 left=30mm,
 right=30mm,
 top=30mm,
 bottom=30mm,
 }
 
\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}{Lema}[theorem]
 
\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
 
\theoremstyle{remark}
\newtheorem*{remark}{Observación}
 
\begin{document}
% Estos comandos deben ir antes del \maketitle
\materia{Algorítmos y Estructuras de Datos III} % obligatorio

\titulo{Trabajo Práctico 1}
\subtitulo{"Knock, knock".- \\
"Who's there?".- \\
$\cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot$ \\
$\cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot \cdot$ \\
"Java".-}
\grupo{}

\integrante{Bayardo Julián}{850/13}{julian@bayardo.com.ar} % obligatorio
\integrante{Cuneo Christian}{755/13}{chriscuneo93@gmail.com} % obligatorio 
\integrante{Frassia Fernando}{340/13}{ferfrassia@gmail.com} % obligatorio 
\integrante{Gambaccini Ezequiel}{715/13}{ezequiel.gambaccini@gmail.com} % obligatorio 
 
\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{Introducción}

\section{Problema 1}

\subsection{Enunciado}
La comunicación es el progreso! decididos a entrar de lleno en la nueva era el país decidió conectar telegráficamente todas las estaciones del moderno sistema férreo que recorre el país en abanico con origen en la capital (el kilómetro 0). Por lo escaso del presupuesto, se ha decidido ofrecer cierta cantidad de kilómetros de cable a cada ramal. Pero para maximizar el impacto en épocas electorales se busca lograr conectar la mayor cantidad de ciudades con los metros asignados (sin hacer cortes en el cable).
Resolver cuantas ciudades se pueden conectar para cada ramal en $O(n)$ , con n la cantidad de estaciones en cada ramal, y justificar por qué el procedimiento desarrollado resuelve efectivamente el problema.

\subsection{Breve descripción del algoritmo}

Para resolver este problema, colocamos los kilometrajes de las ciudades en una lista, luego creamos cuatro variables para recordar el comienzo y fin del camino actual, y el comienzo y fin del mejor camino (en este caso, el que incluye a la mayor cantidad de ciudades). \\
Al ir recorriendo la lista de ciudades, mientras que podamos avanzar nuestro fin de camino actual sin pasarnos de la cantidad de metros disponibles a utilizar, avanzamos el fin, y si por el contrario, no podemos avanzar más debido a que excederíamos la cantidad de metros disponibles, avanzamos el principio del camino actual (para recuperar metros disponibles) hasta que podamos avanzar (porque tenemos más metros disponibles de los que requiere conectar la siguiente ciudad, o porque ni con todos los disponibles posibles podemos hacerlo, con lo cual dejamos el inicio y el fin en esta ciudad, y avanzamos). \\
En cada iteración, comparamos la cantidad de ciudades acumuladas en el camino actual contra las acumuladas en el mejor camino, y de ser el caso, lo actualizamos. \\
Finalmente, obtenemos las posiciones donde se inicia y se termina el mejor camino, y devolvemos la diferencia entre sus índices + 1. \\

\nuevoAlgo{Algoritmo 1}{maxCantDeCiudades($meters$: $Nat$, $distances$: $Vector<Nat>$)} $\rightarrow$ $res$ :
$Nat$ \\ 
Dado un natural (Meters) y una lista de distancias entre ciudades (Distances), devuelve la cantidad máxima de ciudades que se pueden recorrer con esta cantidad de metros. \\ 

\begin{tabular}{rp{17cm}}
1: & maxCantDeCiudades ($meters$: $Nat$, $distances$: $Vector<Nat>$)\ \{\\
2: & \hspace{0,5cm} \asignar{bestStart}{0} \\
3: & \hspace{0,5cm} \asignar{bestEnd}{0} \\ 
4: & \hspace{0,5cm} \asignar{start}{0} \\
5: & \hspace{0,5cm} $\forall$ end $\in$ distances \{\\
6: & \hspace{1cm} $\textbf{si}$ distances[end] - distances[start] $>$ meters \{\\
7: & \hspace{1,5cm} $\mientras$ distances[end] - distances[start] $>$ meters $\wedge$ start $<$ end \{\\
8: & \hspace{2cm} start++ \\
9: & \hspace{1,5cm} \}\\
10: & \hspace{1cm} \}\\
11: & \hspace{1cm} $\textbf{si}$ end - start $>$ bestEnd - bestStart \{\\
12: & \hspace{1,5cm} bestStart = start \\
13: & \hspace{1,5cm} bestEnd = end \\
14: & \hspace{1cm} \}\\
15: & \hspace{0,5cm} \asignar{output}{0} \\
16: & \hspace{0,5cm} $\textbf{si}$ bestStart $\neq$ bestEnd \{\\
17: & \hspace{1cm} \asignar{output}{bestEnd - bestStart + 1} \\ 
18: & \hspace{0,5cm} \}\\
19: & \hspace{0,5cm} \devolver output \\
20: & \}\\
 
\end{tabular}

\begin{algorithmic}[1]
\Procedure{maxCantDeCiudades}{$meters: Nat$, $distances: Vector<Nat>$}
\State bestStart = 0
\State $bestEnd\gets 0$
\State $start\gets 0$
\For {$end = 0$ , $end < tamaño(distances)$ , $end = end + 1$}
\If {$distances[end] - distances[start] > meters$}
\While{$distances[end] - distances[start] > meters$ $\wedge$ $start < end$}
\State start++
\EndWhile\label{euclidendwhile}
\EndIf
\If {end - start}
\EndFor
\State \textbf{return} $b$\Comment{The gcd is b}
\EndProcedure
\end{algorithmic}


\subsection{Correctitud}
Para convencernos de que nuestro algoritmo es correcto, veamos cómo funciona el mismo, y por qué la solución que se obtiene de él es una solución al problema. \\ 
Para esto, debemos ver que: primero, estamos armando correctamente el camino a conectar, es decir, que la suma de las distancias entre las ciudades del camino es menor que la cantidad de metros disponible y además es el más largo (es decir, si alargáramos el camino desde el principio hacia atrás, no obtendríamos un camino válido); y segundo, que finalmente obtenemos el camino válido que contiene a la mayor cantidad de ciudades posibles. \\
Con respecto al primer punto, veamos que cada vez que iteramos por una ciudad, nos preguntamos si podemos anexarla a nuestro camino de acuerdo a la cantidad de metros que tenemos y la "longitud" del camino. Y de no ser posible anexarla, recortamos el principio (de a una ciudad por vez) hasta llegar a una "longitud" que sí nos permita anexarla. No está de más aclarar que buscamos el mínimo recorte de camino posible, y es por eso que en cada "recorte" nos preguntamos si en ese instante podemos anexarla. Habiendo dicho esto, podemos decir que para cada ciudad, la estamos incluyendo en un camino parcial válido, y además es el máximo de los caminos actuales que podemos formar con esa ciudad como fin. \\

Con respecto al segundo aspecto, en cada iteración, estamos comparando la longitud del camino actual contra la longitud del mejor camino parcial, y actualizándolo según el caso. Entonces, luego de iterar por todas las ciudades, tendremos la longitud del mejor camino total. \\

Habiendo cumplido ambos aspectos, podemos decir que el algoritmo es correcto.

\subsection{Demostración}

Sea V = $\{\mathcal{V}_1,..., \mathcal{V}_n\}$ una secuencia de n posiciones de ciudades, sea m la cantidad de kilómetros de cable para conectarlas y sea V' = V$_[i..j]$ con i,j $\in$ $\{1..n\}$, i $\leq$ j (es decir, V' es una subsecuencia válida de V si y sólo si $\mathcal{V}_j$ - $\mathcal{V}_i$ $\leq$ m $\wedge$ $\nexists$ i' $<$ i $/$ $\mathcal{V}_j$ - $\mathcal{V}_i'$ $\leq$ m). \\

Quiero ver que $\forall$ j $\in$ $\{1..n\}$, en la j-ésima iteración, el algoritmo elige i tal que la subsecuencia $\mathcal{V}_[i..j]$ es válida.\\

P(j) = $\forall$ j $\in$ $\{1..n\}$, en la j-ésima iteración, el algoritmo elige i $/$ \\
a) $\mathcal{V}_j$ -  $\mathcal{V}_i$ $\leq$ m $\wedge$ \\
b) i $\leq$ j $\wedge$ \\
c) $\nexists$ i' $<$ i $/$ $\mathcal{V}_j$ - $\mathcal{V}_i'$ $\leq$ m \\

Caso Base:\\
P(1) = En la primera iteración, el algoritmo elige i $/$ $\mathcal{V}_j$ - $\mathcal{V}_i$ $\leq$ m \\

a) Notemos que no se cumple la guarda del primer condicional, dado que $end(j)$ y $start(i)$ son ambos la primera posición de la secuencia V. Entonces, como i = j, $\mathcal{V}_j$ -  $\mathcal{V}_i$ = 0, que es siempre menor a m, por ser m una distancia. \\

b) Como ya notamos, siendo la primera iteración, i = j, con lo cual vale b. \\

c) Dado que i es la primera posición de la secuencia, no existe un i' menor a él, con lo cual vale c.\\

Paso Inductivo:\\
Quiero ver que $\forall$ j $\in$ $\{2..n\}$, P(j - 1) $\Rightarrow$ P(j) \\ 
Hipótesis Inductiva: Vale P(j - 1), es decir, vale que para j-1-ésima iteración, el algoritmo eligió i $/$ \\
a) $\mathcal{V}_j-1$ - $\mathcal{V}_i$ $\leq$ m $\wedge$ \\
b) i $\leq$ j - 1 $\wedge$\\
c) $\nexists$ i' $<$ i $/$ $\mathcal{V}_{j-1}$ - $\mathcal{V}_i'$ $\leq$ m \\

Como acabo de cubrir una nueva ciudad, tengo que ver los casos en que:\\
1) $\mathcal{V}_j$ - $\mathcal{V}_i$ $\leq$ m \\
2) $\mathcal{V}_j$ - $\mathcal{V}_i$ $>$ m \\

CASO 1: $\mathcal{V}_j$ - $\mathcal{V}_i$ $\leq$ m \\
a) Dado que estoy en el caso 1, vale.\\
b) Dado que la única línea que podría modificar i no se ejecuta (por caso), y como j $>$ j - 1, se tiene que: i $\leq$ j - 1 $\wedge$ j - 1 $<$ j $\Rightarrow$ i $\leq$ j \\
c) Sé que $\nexists$ i' $<$ i $/$ $\mathcal{V}_{j-1}$ - $\mathcal{V}_i'$ $\leq$ m (por HI), quiero ver que $\nexists$ i' $<$ i $/$ $\mathcal{V}_j$ - $\mathcal{V}_{i'}$ $\leq$ m \\

Veamos por el absurdo: \\
Sé que $\forall$ j $\in$ \{2..n\} vale que $\mathcal{V}_{j-1}$ $<$ $\mathcal{V}_j$, por orden creciente estricto. \\
Si existiera i' $<$ i $/$ $\mathcal{V}_j$ - $\mathcal{V}_i'$ $\leq$ m \\
significaría que:  $\mathcal{V}_{j-1}$ - $\mathcal{V}_{i'}$ $<$ $\mathcal{V}_j$ - $\mathcal{V}_i'$ $\leq$ m \\
entonces: $\mathcal{V}_{j-1}$ - $\mathcal{V}_i'$ $\leq$ m   ABS! \\
es absurdo porque sabíamos que no existía i' que cumpliera con eso. \\

CASO 2: $\mathcal{V}_j$ - $\mathcal{V}_i$ $>$ m \\
a) Dado que la secuencia está ordenada de forma estrictamente creciente y que mientras $\mathcal{V}_j$ - $\mathcal{V}_i$ sea mayor estricto que m el algoritmo aumenta i en una unidad, $\mathcal{V}_j$ - $\mathcal{V}_i$ va reduciéndose hasta ser menor o igual a m, donde i se detiene y el ciclo termina. Esto sucede de una de dos formas: \\

O bien $\exists$ i' $<$ i'' $/$ $\mathcal{V}_j$ - $\mathcal{V}_{i''}$ $\leq$ m \\
en cuyo caso se obtiene que i pasa a valer i'', y se cumple a).

O bien $\nexists$ i' $<$ i'' $/$ $\mathcal{V}_j$ - $\mathcal{V}_{i''}$ $\leq$ m \\
en cuyo caso, al llegar i = j, $\mathcal{V}_j$ - $\mathcal{V}_i$ = 0, lo cuál es menor o igual a m, por ser m una distancia. \\

b) Notemos que la guarda del ciclo chequea si $\mathcal{V}_j$ - $\mathcal{V}_i$ $>$ m $\wedge$ i $<$ j, y que i aumenta de a uno. \\
(Es la segunda parte del o bien anterior. )
c) Idem al c) del CASO 1.\\

Por CASO 1 y CASO 2, vale P(j).\\

Ahora sabemos que los caminos generados en cada iteración son válidos, pero lo que nos falta probar es que en cada iteración, nos quedamos con el más largo de todos hasta el momento. \\
Quiero ver que $\forall$ j $\in$ \{1..n\}, en la j-ésima iteración, el algoritmo se queda con el camino válido más largo hasta j. \\

P(j) = en la j-ésima iteración, el algoritmo se queda con el camino válio más largo hasta j. \\

Caso Base: \\
P(1) = No hay camino válido con una sola ciudad, con lo cual me quedo con el camino válido nulo, que siendo el único, es el más largo. \\

Paso Inductivo: \\
Quiero ver que $\forall$ j $\in$ \{2..n\}, P(j - 1) $\Rightarrow$ P(j) \\
Hipótesis Inductiva: Vale P(j - 1), es decir, para la j-1-ésima iteración, el algoritmo se queda con el camino vñalido más largo hasta j - 1. \\

Quedan dos casos a evaluar en la iteración j: \\
CASO 1: \\
$\vert$camino válido(j)$\vert$ $\leq$ $\vert$camino válido(j-1)$\vert$ \\
CASO 2: \\
$\vert$camino válido(j)$\vert$ $>$ $\vert$camino válido(j-1)$\vert$ \\

CASO 1:
Como el $\vert$camino válido(j)$\vert$ es menor o igual al de j - 1, no modificamos el camino guardado hasta el momento, y como sabíamos que valía P(j-1), es decir que era el camino válido más largo hasta j - 1, vale que es el camino válido más largo hasta j. Osea, vale P(j). \\

CASO 2:
Acá se cumple la guarda del condicional y nos quedamos con el camino válido(j). Y como por HI valía que hasta j - 1 nos habíamos quedado con el camino válido más largo (hasta j - 1), y en j encontramos uno más largo que ese, entonces vale que en particular el camino j es el más largo hasta j. \\

Como probamos P(j) para el CASO 1 y el CASO 2, y ambos son exhaustivos, vale P para todo j, es decir, el algoritmo siempre se queda con el camino vñalido más largo hasta j. \\

Por ambas demostraciones, probamos que el algoritmo genera un camino válido en cada iteración, y además se queda con el más largo hasta el momento. \\


\subsection{Complejidad}

\subsection{Análisis}

\section{Problema 2}

\subsection{Enunciado}

La mediana de un conjunto ordenado de $n$ números se define como $x_{(n+1)/2}$ si $n$ es impar, o como $(x_{n/2} + x_{(n/2)+1})/2$ si $n$ es par. Dados $n$ números enteros en cualquier orden se deben devolver otros $n$ números, donde el i-ésimo de ellos represente la parte entera de la mediana de los primeros $i$ números de la entrada.
Resolver en una complejidad estrictamente mejor que $O(n^2)$ donde $n$ es el número total de enteros de entrada.

\subsection{Breve descripción del algoritmo}
En este problema decidimos insertar uno por uno los elementos de entrada en una estructura especifica tal que los elementos queden ordenados y los datos necesarios para calcular la mediana se encuentren siempre a mano. Para esto decidimos utilizar un max-heap y un min-heap. Al ingresar nuevos elementos a nuestra estructura se va a hacer de forma tal que la cantidad de elementos que tiene cada heap difieran a lo sumo en 1, y que la cabeza del max-heap sea menor a la cabeza del min-heap. En otras palabras, el conjunto de elementos estará dividido en dos, quedando los elementos mas pequeños en el max-heap, y los mas grandes en el min-heap.\par
El objetivo de esta estructura es que, en cada paso, los elementos necesarios para calcular la mediana se encuentren en las cabezas de los heaps. 
Sabiendo que la inserción en un heap cuesta $O(log n)$ siendo $n$ la cantidad de elementos en el heap, al igual que eliminar la cabeza. 
Nuestro algoritmo insertara todos los elementos de entrada en el heap que corresponda, que serán siempre de tamaño como mucho $n/2$, este proceso provocara como mucho dos inserciones en heap y una quita de cabeza para mantener el invariante de la estructura (se vera mas claramente en el Algoritmo).



\subsection{Correctitud}

Definimos las siguientes funciones: \\

\newcommand{\twopartdef}[4]
{
	\left\{
		\begin{array}{ll}
			#1 & \mbox{if } #2 \\
			#3 & \mbox{if } #4 \\
		\end{array}
	\right.
}

\newcommand{\fourpartdef}[8]
{
	\left\{
		\begin{array}{ll}
			#1 & \mbox{if } #2 \\
			#3 & \mbox{if } #4 \\
			#5 & \mbox{if } #6 \\
			#7 & \mbox{if } #8 \\
		\end{array}
	\right.
}

    Min: $C \rightarrow \mathds{Z} , \  C \subseteq \mathds{Z} $  
    
    Min(C) = $\twopartdef{ x \in C  \Leftrightarrow \forall y \in C, x \leq y }{\#C > 0}{\infty}{\#C = 0}$ \\ \\

    Max: $C \rightarrow \mathds{Z} , \  C \subseteq \mathds{Z} $ 
    
    Max(C) = $x \in C  \Leftrightarrow \forall y \in C, x \geq y$ \\ \\

    Mediana: $L \  x\  R \  \rightarrow \mathds{Z}, \ L \subseteq \mathds{Z}, \ R \subseteq \mathds{Z}$
    
    Sujeto a:  $\#L > 0  \wedge  (1 \geq \#L - \#R \geq 0) \wedge ((\#R > 0 \wedge \#L > 0) \rightarrow \forall x \in L \forall y \in R (x \leq y) )$ \\ 
    
    Mediana(L, R) = $\twopartdef { \frac{Max(L) + Min(R)}{2} } {\#L = \#R} {Max(L)} {\#L \neq \#R}$\\ \\

    
    
    Agregar: $L\ x\ R\ x\ \mathds{Z}\ \rightarrow L'\  x\  R', L \subseteq \mathds{Z}, \ R \subseteq \mathds{Z}, \ L' \subseteq \mathds{Z}, \ R' \subseteq \mathds{Z}, \ $\\
    
    Agregar(L, R, x) = $\fourpartdef { L  \ \cup \{x\}, R} 
                                    {\#L = \#R   \wedge \ \text{Min}(R) \geq x} 
                                    { L  \ \cup \{Min(R)\}, (R - \{Min(R)\}) \cup \{x\}}
                                    { \#L > 0  \wedge \ \#L = \#R \wedge \text{Min}(R) < x}
                                    {L, R \ \cup \{x\}}
                                    {\#L > 0  \wedge \ \#L \neq \#R \wedge \text{Max}(L) < x}
                                    {(L - Max(L)) \ \cup \{x\}, R \ \cup \{Max(L)\} }
                                    {\#L > 0  \wedge \ \#L \neq \#R \wedge \text{Max}(L) \geq x}$\\
      \\
          
\textbf{Predicado Inductivo}: Mediana(L, R) devuelve la mediana de un conjunto ordenado resultado de la unión de 2 conjuntos. Estos 2 conjuntos deben cumplir con la precondición de mediana.\\


\textbf{Caso Base N = 1} \\

L = \{\} \\  

R = \{\} \\ 

x $\in \mathds{Z}$ \\ \\

Mediana(Agregar(L, R, x)) = 
Mediana(Agregar(\{\}, \{\}, x)) =
Mediana(\{\} $\cup$ \{x\}, \{\}) $\rightarrow$ \\ 
\#(\{\} $\cup$ \{x\}) = 1 $>$ 0 = \#(\{\}) $\rightarrow$
Mediana(\{x\}, \{\}) = Max(\{x\}) = x $\rightarrow$ x es la mediana por ser único elemento \\ \\

\textbf{Paso Inductivo} \\

Supongo que es verdadero para N, N $>$ 1, analizo para N+1.\\

Hay que analizar para el caso que \#L + \#R = N sea par y para el caso que sea impar. \\

En el caso que N sea impar, \#L - \#R = 1 por precondición de Mediana. \\

Por hipótesis inductiva, ambos conjuntos cumplen la siguiente condición para ambos casos de N (par e impar): 

(1 $\geq$ \#L - \#R $\geq$ 0) $\wedge$ ((\#R $>$ 0 $\wedge$ \#L $>$ 0) $\rightarrow$ $\forall$ x $\in$ L $\forall$ y $\in$ R (x $\leq$ y) ) \\

\textbf{Caso N Par}\\ 

L y R ambos cumplen la hipótesis inductiva.\\

Si N es par $\rightarrow$ \#L = \#R = N/2 $\wedge$ N $>$ 1.\\ 

x $\in \mathds{Z}$ \\

Mediana(Agregar(L, R, x)) $\rightarrow \twopartdef{ a) Mediana(L \ \cup \{x\})}
                                                        {x \ \leq Min(R)}
                                                    {b) Mediana(L  \ \cup \{Min(R)\}, (R - \{Min(R)\}) \cup \{x\})}
                                                        {x > Min(R)}$\\
                                                        
\underline{Caso a}\\

Defino L' = L $\ \cup$ \{x\}.\\

Como x $\leq$ Min(R), L' sigue cumpliendo la precondición de mediana, ya que \#L' = 1 + N/2, \\ \#R = N/2, su diferencia es 1, y además $\forall$ x $\in$ L', $\forall$ y $\in$ R, x $\leq$ y. \\
Si L' $\cup$ R fuese un arreglo ordenado de números, su cardinal sería $1 + 2 * \frac{N}{2} = N + 1 \equiv 1 \mod 2$, por lo que la mediana sería el elemento $1 + \frac{N}{2}$ de ese arreglo. \\
Como \#L' = $1 + \frac{N}{2}$, y todos sus elementos son menores a los elementos de R, es decir, L' es la mitad más chica de un arreglo de longitud impar, teniendo L' de longitud $1 + \frac{N}{2}$, y el arreglo longitud N, la mediana debe ser el elemento más grande de este conjunto, ya que el máximo de L' es equivalente al elemento $1 + \frac{N}{2}$ del arreglo ordenado de L' $\cup$ R $\rightarrow$ Mediana(L', R) = Max(L'), que es lo que devuelve Mediana(L', R) para este caso, como queríamos demostrar.\\

\underline{Caso b}\\

Defino L' = L $\cup$ \{Min(R)\}.  \#L' = 1 + N/2 . \\

Defino R' = (R - \{Min(R)\}) $\cup$ \{x\}. \#R' = N/2 - 1 + 1 = N/2. \\

Como x $>$ Min(R), y como \#L = \#R, para mantener la precondición de Mediana, hay que extraer el mínimo de R para luego agregar x y así evitar que \#R $>$ \#L, por eso la definición anterior de R'. Luego, el mínimo extraído de R se agrega a L, quedando así definido R'. \\
De esta manera, L' y R' respetan la precondición de Mediana, ya que \\ \#L' = 1 + N/2, \#R' = N/2 $\rightarrow$ \#L' - \#R'= 1, y además, $\forall$ x $\in$ L', $\forall$ y $\in$ R', x $\leq$ y. \\
Si L' $\cup$ R' fuese un arreglo ordenado de números, su cardinal sería $1 + 2 * \frac{N}{2} = N + 1 \equiv 1 \mod 2$, por lo que la mediana sería el elemento $1 + \frac{N}{2}$ de ese arreglo. \\
Por cumplir con la precondición de Mediana, L' es la mitad más chica de un arreglo de longitud impar, teniendo L' de longitud $1 + \frac{N}{2}$, y el arreglo longitud N, la mediana debe ser el elemento más grande de este conjunto, ya que el máximo de L' es equivalente al elemento $1 + \frac{N}{2}$ del arreglo ordenado de L' $\cup$ R' $\rightarrow$ Mediana(L', R') = Max(L'), que es lo que devuelve Mediana(L', R') para este caso, como queríamos demostrar.\\

\textbf{Caso N Impar} \\ 

L y R ambos cumplen la hipótesis inductiva.\\

Si N es impar $\rightarrow$ \#L = 1 + N/2, \#R = N/2 $\wedge$ N $>$ 1.\\ 

x $\in \mathds{Z}$ \\

Como $\#L \neq \#R$: \\

Mediana(Agregar(L, R, x)) $\rightarrow \twopartdef{c) L, R \ \cup \{x\}}
                                    {Max(L) < x}
                                    {d) (L - \{Max(L)\}) \ \cup \{x\}, R \ \cup \{Max(L)\} }
                                    {Max(L) \geq x}$\\
                                    
\underline{Caso c} \\

Defino R' = R $\cup$ \{x\}. \\

Por hipótesis inductiva, \#L = 1 + N/2 y \#R = N/2. Como x $>$ Max(L), y \#R $<$ \#L, se puede definir R' sin romper la precondición de Mediana.
Si L $\cup$ R' fuese un arreglo ordenado, su longitud sería $1 + 2 * \frac{N}{2} = N + 1 \equiv 0 \mod 2$, ya que \#L = 1 + N/2 = \#R', su mediana sería el promedio entre los elementos $\frac{N+1}{2}$ y $\frac{N+1}{2} + 1$, L sería la mitad con los menores elementos del arreglo, y R' sería la mitad con los mayores elementos del arreglo $\rightarrow$ el elemento $\frac{N+1}{2}$ es el máximo de L y el elemento $\frac{N+1}{2} + 1$ es el mínimo de R'$\rightarrow$ $Mediana(L, R') = \frac{Max(L) + Min(R')}{2}$, como se quería probar. \\

\underline{Caso d} \\

Defino L'= (L - \{Max(L)\}) $\ \cup$ \{x\}, \#L'= 1 + N/2 - 1 + 1 = 1 + N/2. \\

Defino R' = R $\ \cup$ \{Max(L)\}, \#R'= 1 + N/2. \\

Como x $\leq$ Max(L), se debería redefinir L como L'= L $\cup$ \{x\}, pero esto rompería la precondición de mediana, ya que \#L' - \#R = 2 $>$ 1, por lo que L' = (L - \{Max(L)\}) $\ \cup$ \{x\}, y se redefine R como R' = R $\ \cup$ \{Max(L)\}. De esta manera, \#L'- \#R' = 0, y además, $\forall$ x $\in$ L', $\forall$ y $\in$ R', x $\leq$ y. \\
Si L' $\cup$ R' fuese un arreglo ordenado, su longitud sería $1 + 2 * \frac{N}{2} = N + 1 \equiv 0 \mod 2$, ya que \#L' = 1 + N/2 = \#R', su mediana sería el promedio entre los elementos $\frac{N+1}{2}$ y $\frac{N+1}{2} + 1$, L' sería la mitad con los menores elementos del arreglo, y R' sería la mitad con los mayores elementos del arreglo $\rightarrow$ el elemento $\frac{N+1}{2}$ es el máximo de L' y el elemento $\frac{N+1}{2} + 1$ es el mínimo de R'$\rightarrow$ $Mediana(L', R') = \frac{Max(L') + Min(R')}{2}$, como se quería probar. \\

Finalmente, de los casos N par e impar y de los subcasos a, b, c, y d, se demuestra que 
Mediana(L, R) devuelve la mediana de un conjunto ordenado resultado de la unión de L y R, cumpliendo L y R con la condición de que $1 \ \geq (\#L - \#R) \ \geq 0 \ \wedge \ ((\#R > 0 \wedge \#L >0) \rightarrow \forall x \in L \ \forall y \in R \ (x \leq y))$

\subsection{Complejidad}

\subsection{Análisis}

\section{Problema 3}

\subsection{Resolución}

Resolver el tercer ejercicio requiere de una observación fundamental: todas las formas de sentarse en ronda para las exploradoras son exactamente las permutaciones que podamos formar con ellas. Esto quiere decir que, en concreto, un algoritmo de fuerza bruta para resolver el problema podría simplemente ser generar todas las permutaciones posibles de exploradoras y buscar la mejor según el criterio indicado por la cátedra, de la misma forma en la que buscamos el máximo o el mínimo de un arreglo. Es muy fácil ver que este algoritmo tomaría una complejidad temporal de $\Theta(e! f(e, a))$ con $e$ el numero de exploradoras, $a$ el numero de amistades entre ellas, y $f$ una función que incluye todos los costos adicionales. Si bien siempre que elijamos una secuencia de operaciones relativamente sanas tendríamos que $f(e, a) \in \Theta(e^3 a^2)$, y es claro que el algoritmo resultante cumpliría con la complejidad requerida por la especificación, así como que podemos mejorar la solución aplicando las técnicas que vimos en la materia.

Fundamentalmente, la idea se basa en que podemos utilizar la técnica de backtracking para explorar el espacio de soluciones del algoritmo y encontrar una que cumpla con todos los requisitos. Veremos, también, que podemos optimizar nuestra solución a través de podas en el árbol de estados a explorar, aumentando drásticamente la eficiencia del algoritmo.

Para comenzar, cabe destacar que si tenemos el conjunto de posibles soluciones (es decir, todas las permutaciones) para $e$ exploradoras, es muy fácil construir el conjunto de posibles soluciones para $e+1$ exploradoras: basta con simplemente insertar la exploradora faltante entre medio de todas las que ya tenemos para cada permutación. Más formalmente:

%% TODO: insertar un grafico explicativo

\begin{lemma}
El algoritmo expuesto genera todas las permutaciones de $n$ elementos.
\label{ej3:generador}
\end{lemma}

\begin{proof}
Sea $M_n = \{1, .., n\}$, además, sea $S_n = \{ f : M_n \to M_n / \text{f es biyectiva}\}$ el conjunto de permutaciones de $M_n$ elementos. Quiero ver que la función $g : S_n \times M_n \to S_{n+1}$ determinada por

$$g((\sigma_1, .., \sigma_n), k) = (\sigma_1, .., \sigma_{k-1}, n+1, \sigma_k, .., \sigma_n)$$

Es una biyeccion. Veamos que es inyectiva, sean $\sigma, \alpha \in S_n$ y $k, l \in M_n$ tales que

$$g(\sigma, k) = g(\alpha, l)$$

Quiero ver que $k = l \wedge \sigma = \alpha$. Pero observemos que esto implica que

$$(\sigma_1, .., \sigma_{k-1}, n+1, \sigma_k, .., \sigma_n) = (\alpha_1, .., \alpha_{l-1}, n+1, \alpha_l, .., \alpha_n)$$

Es decir, $\sigma_k = n + 1 = \sigma_l$. Como cada elemento aparece una única vez, $k = l$, implicando entonces que $\sigma_i = \alpha_i \forall i \in M_n$, pues de otra forma la igualdad no se cumple. Veamos ahora que es sobreyectiva, sea $\alpha \in S_{n+1}$, sabemos que $\exists l \in M_{n+1} : \alpha_l = n+1$, tomemos entonces $\sigma = (\alpha_1, .., \alpha_{l-1}, \alpha_{l+1}, .., \alpha_{l+1})$, evaluar $g(\sigma, l)$ da el resultado esperado.

Observemos que la función $g$ es precisamente la que intercala al elemento $n+1$ en la permutación para cada una de las posiciones, implicando que un algoritmo que haga exactamente eso va a generar todas las permutaciones.
\end{proof}

Por lo tanto, tenemos la condición fundamental para crear un algoritmo que realice backtracking, ya que comenzando con una solución vacía podemos generar todos los conjuntos de soluciones incrementalmente hasta llegar al conjunto total de soluciones posibles para la cantidad de exploradoras que deseemos.

Yendo mas lejos, notemos que la semántica adherida por estar considerando rondas implica que las permutaciones que sean rotaciones entre ellas son equivalentes: a modo de ejemplo, las permutaciones $\{(1, 2, 3, 4), (4, 1, 2, 3), (3, 4, 1, 2), (2, 3, 4, 1)\}$ son todas equivalentes miradas como rondas, ya que los extremos están unidos entre si, de forma análoga a las listas circulares. Por lo tanto, podemos intentar evitar generar rotaciones de una permutación.

\begin{lemma}
Insertar en las ultimas $n-1$ posiciones no borra soluciones posibles
\label{ej3:poda1}
\end{lemma}

\begin{proof}
Es claro que insertar adelante es lo mismo que insertar al final, ya que como rondas ambas son equivalentes:

$$(i_1, .., i_n, n+1) \equiv (n+1, i_1, .., i_n)$$

Con $i_j$ un ordenamiento arbitrario de los números en $M_n$. Además, $i_1 < n+1$ por lo que la primer alternativa es estrictamente menor lexicográficamente que la segunda, implicando que como solución es mejor (por los parámetros determinados por la cátedra) y, por lo tanto, la primer alternativa siempre debería ser elegida antes que la segunda.
\end{proof}

Entonces, podemos explorar el espacio de soluciones en forma de árbol, donde la cabeza es la permutación con un solo elemento, y cada nivel está definido en términos del anterior como aplicar la función $g$ del lema \ref{ej3:generador} a todos los nodos del nivel anterior, utilizando cada uno de los $n-1$ valores más grandes de $M_n$. Observemos, además, que podemos explorar el árbol de forma tal que las permutaciones de menor orden lexicográfico sean exploradas antes, simplemente eligiendo los índices para la inserción de mayor a menor.

%% TODO: insertar imagen del arbol

La próxima pregunta natural a realizarse es cual es el tamaño del árbol de búsqueda, que es lo que nos va a permitir estimar la complejidad esperada de nuestra solución:

\begin{lemma}
El árbol de soluciones tiene a lo sumo $(n-1)!$ nodos en cada nivel $n$. Además, cada uno de los nodos en el nivel tiene exactamente $n$ exploradoras.
\label{ej3:arbol-nodos}
\end{lemma}

\begin{proof}
Por inducción en el nivel. Cuando $n = 1$, observemos que $(n-1)! = 0! = 1$, y claramente el primer nivel del árbol solo contiene a la permutación $(a)$, por lo que es válido el caso base.

Supongamos que vale para $n$, veamos que vale para $n+1$. Por hipótesis inductiva, los nodos en la frontera son de longitud $n$, y además son en total $(n-1)!$.

Para cada uno de los nodos de la ya explorados, el algoritmo obtiene una de las exploradoras faltantes y la intercala entre cada uno de los índices posibles, comenzando por el $n$-ésimo (el índice $n-1$, ya que estamos indexados desde $0$) y terminando en el índice $1$, por lo que generamos exactamente $n$ nuevos nodos de longitud $n+1$, lo que demuestra la segunda parte del lema.

Además, cada uno de los $(n-1)!$ nodos de la ya explorados tiene exactamente $n$ hijos, y por lo tanto la cantidad de nodos en el nivel $n+1$ es de $(n-1)! n = n! = ((n + 1) - 1)!$; demostrando así la primer parte del lema.
\end{proof}

\begin{corollary}
La cantidad de nodos explorados es $O(e!)$.
\label{ej3:arbol-total}
\end{corollary}

\begin{proof}
Por el lema anterior, basta con explorar $e$ niveles del árbol, por lo que tenemos que la cantidad de nodos a explorar es, a lo sumo

\begin{equation}
\begin{aligned}
\sum_{i=1}^{e} (i-1)! &= \sum_{i=0}^{e-1} i! \\
&\leq \sum_{i=0}^{e-1} (e-1)! \\
&= (e-1)! (e-1) \in O(e!)
\end{aligned}
\end{equation}

Cabe destacar que, de cualquier forma, las cotas aplicadas en este corolario no son para nada ajustadas, por lo que la cota superior por $e!$ únicamente nos permite demostrar que este algoritmo no es peor que realizar la solución por fuerza bruta.
\end{proof}

\begin{definition}
Una permutación es menor a otra cuando la suma de las distancias entre amistades es menor. En caso de que la mismas sean iguales, consideramos que es menor si la máxima distancia entre amistades es menor. En caso de que estas ultimas sean iguales, decimos que es menor si es menor lexicográficamente (es decir, posición a posición de la permutación). 
\end{definition}

\begin{definition}
Una permutación es completa cuando la cantidad de elementos de la misma son exactamente la cantidad de exploradoras. Por otro lado, una permutación es parcial cuando es obtenida por el proceso iterativo que describimos anteriormente, y no es completa.
\end{definition}

\begin{lemma}
Dada una permutación completa al problema, cualquier permutación parcial mayor o igual a la permutación dada no va a ser solución del problema.
\end{lemma}

\begin{proof}
Observemos que al insertar un nuevo elemento, la suma de las distancias entre amistades de la solución parcial solo puede aumentar, llegando entonces a una permutación cuya suma de distancias va a ser mayor estricta que la que ya tenemos, y que por lo tanto no puede ser la solución del problema.
\end{proof}

Es decir, una vez que tenemos una permutación completa generada podemos comenzar a purgar todas las ramas que generen alguna permutación mayor a la que ya tenemos, y esa purga no va a borrar ninguna solución valida. Con esto, tenemos todas las ideas fundamentales para construir nuestro algoritmo de backtracking: comenzando con la solución para una sola exploradora, podemos ir generando las soluciones para cada vez más exploradoras, hasta llegar al final del árbol de estados. Más todavía, podemos ir generando las permutaciones de una forma inteligente, tal que exploremos el árbol primero en profundidad y, al llegar la primera solución completa, comenzar a purgar las ramas todavía no exploradas. Pensando en esto, proponemos el siguiente algoritmo como solución al problema:

%% TODO: el puto pseudocodigo.

\subsection{Correctitud}

Como vimos anteriormente, las ideas de trasfondo en el algoritmo son efectivamente correctas, ya que generan todo el espacio de soluciones posibles. Por lo tanto, consideramos que lo único que estaría faltando ver es que realmente el algoritmo realmente se corresponde con esto.

\subsection{Complejidad}

\subsection{Análisis}

\section{Conclusión}

\section{Código fuente}

\end{document}